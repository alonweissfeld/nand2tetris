class DirectionGame {
    // Determines the square and it's direction for this game.
    // 0=none, 1=up, 2=right, 3=down, 4=left
    field Square square;

    // Determines the user collected score.
    field int score;

    // Determines the levels array. Each level represents the current
    // round in the game, and is structured from the direction in which
    // the square moves, a delay that determines the speed of
    // it's movement and the text shown - which is the actual answer.
    field Array levels;
    field int levelsAmount;
    field boolean moreLevels;

    // Determines the current level being played.
    field Level currentLevel;
    field int currentLevelIdx;

    /** Initializes a new Direction Game. */
    constructor DirectionGame new() {
        // Set up the levels/rounds of the game.
        do setUpLevels();
        return this;
    }

    /** Set up the levels of the game. */
    method void setUpLevels() {
        let currentLevelIdx = -1;
        let levelsAmount = 40;
        let levels = Array.new(levelsAmount);

        // Remainder: 0=none, 1=up, 2=right, 3=down, 4=left
        // Level constructor receives the direction of the square,
        // time delay that determines how fast the square is moving
        // and a text string which is the actual answer.

        // Side note: The following code is generated by a python
        // script that first gives higher delay times, then advancing
        // to lower values which requires the user to response
        // quicker, i.e., increase in the difficulty of the game.
        let levels[0] = Level.new(2, 29, "RIGHT");
        let levels[1] = Level.new(2, 28, "LEFT");
        let levels[2] = Level.new(4, 26, "UP");
        let levels[3] = Level.new(4, 28, "LEFT");
        let levels[4] = Level.new(2, 26, "UP");
        let levels[5] = Level.new(4, 24, "DOWN");
        let levels[6] = Level.new(4, 21, "RIGHT");
        let levels[7] = Level.new(2, 30, "UP");
        let levels[8] = Level.new(1, 19, "LEFT");
        let levels[9] = Level.new(4, 10, "RIGHT");
        let levels[10] = Level.new(3, 12, "LEFT");
        let levels[11] = Level.new(4, 13, "LEFT");
        let levels[12] = Level.new(3, 14, "UP");
        let levels[13] = Level.new(1, 15, "UP");
        let levels[14] = Level.new(2, 15, "UP");
        let levels[15] = Level.new(3, 14, "RIGHT");
        let levels[16] = Level.new(3, 5, "RIGHT");
        let levels[17] = Level.new(2, 6, "DOWN");
        let levels[18] = Level.new(2, 9, "LEFT");
        let levels[19] = Level.new(3, 9, "RIGHT");
        let levels[20] = Level.new(1, 6, "UP");
        let levels[21] = Level.new(2, 7, "RIGHT");
        let levels[22] = Level.new(3, 6, "DOWN");
        let levels[23] = Level.new(2, 7, "LEFT");
        let levels[24] = Level.new(1, 5, "RIGHT");
        let levels[25] = Level.new(4, 6, "UP");
        let levels[26] = Level.new(4, 5, "DOWN");
        let levels[27] = Level.new(4, 5, "RIGHT");
        let levels[28] = Level.new(1, 3, "DOWN");
        let levels[29] = Level.new(1, 6, "LEFT");
        let levels[30] = Level.new(3, 7, "RIGHT");
        let levels[31] = Level.new(1, 3, "DOWN");
        let levels[32] = Level.new(3, 4, "LEFT");
        let levels[33] = Level.new(2, 12, "LEFT");
        let levels[34] = Level.new(4, 3, "LEFT");
        let levels[35] = Level.new(3, 3, "RIGHT");
        let levels[36] = Level.new(1, 9, "DOWN");
        let levels[37] = Level.new(1, 4, "RIGHT");
        let levels[38] = Level.new(1, 4, "UP");
        let levels[39] = Level.new(2, 12, "LEFT");
        return;
    }

    /** Disposes this game. */
    method void dispose() {
        do square.dispose();
        do Memory.deAlloc(this);
        return;
    }

    /** Invokes graphical interfaces. */
    method void startGraphics() {
        // Run the square in the current direction
        do moveSquare(currentLevel.getDirection());

        // Delays the next movement
        do Sys.wait(currentLevel.getDelay());
        return;
    }

    /** Listener for when a square reaches the screen edge. */
    method void reachedEdge() {
        let moreLevels = advanceLevel();
        return;
    }

    /**
     * Advances the game to to the next level/round.
     * Returns the boolean state for advancing to the next level,
     * i.e., false if there are no more levels.
     */
    method boolean advanceLevel() {
        if (currentLevelIdx = (levelsAmount - 1)) {
            return false; // No more levels.
        }

        let currentLevelIdx = currentLevelIdx + 1;
        let currentLevel = levels[currentLevelIdx];

        // Reposition the square
        do Screen.clearScreen();
        do repositionSquare(currentLevel.getDirection());

        // Display new level text.
        do Text.displayLevel(currentLevel.getText());
        return true;
    }

    /** Moves the square in the given direction, */
    method void moveSquare(int dir) {
        if (dir = 1) { do square.moveUp(); }
        if (dir = 2) { do square.moveRight(); }
        if (dir = 3) { do square.moveDown(); }
        if (dir = 4) { do square.moveLeft(); }
        return;
    }

    /** Checks the user input against the current text displayed. */
    method void checkUserInput(String txt, char key) {
        if ((key = 131) & (Text.equals(txt, "UP"))) {
            let score = score + 1;
        }
        if ((key = 132) & (Text.equals(txt, "RIGHT"))) {
            let score = score + 1;
        }
        if ((key = 133) & (Text.equals(txt, "DOWN"))) {
            let score = score + 1;
        }
        if ((key = 130) & (Text.equals(txt, "LEFT"))) {
            let score = score + 1;
        }

        return;
    }

    /**
     * Reposition the square for the next round, according
     * to the given direction.
     */
    method void repositionSquare(int dir) {
        // Remainder: 0=none, 1=up, 2=right, 3=down, 4=left
        if (dir = 1) { let square = Square.new(239, 186, 35, this); }
        if (dir = 2) { let square = Square.new(239, 90, 35, this); }
        if (dir = 3) { let square = Square.new(239, 90, 35, this); }
        if (dir = 4) { let square = Square.new(239, 90, 35, this); }
        return;
    }

    /** Waits for any key to be pressed. */
    method void waitForUser() {
        var char key;
        while (key = 0) {
            // Waits for a key to be pressed.
            let key = Keyboard.keyPressed();
        }
        return;
    }

    /** Continuously runs the game until there are no more levels. */
    method void run() {
        var char key;
        var boolean exit;

        do Text.printInstructions();
        do waitForUser();

        // First level.
        do advanceLevel();

        let exit = false;
        while (~exit) {
            // Waits for a key to be pressed.
            while ((key = 0) & (moreLevels)) {
                // keyPressed returns the character of the currently pressed
                // key on the keyboard. If no key is currently
                // pressed, returns 0
                let key = Keyboard.keyPressed();

                // Invoke any graphical interfaces.
                do startGraphics();
            }

            if (key = 81)  { let exit = true; }     // q key

            // Check the user input. If the key which is pressed equals
            // to the text of the current round, increase the score.
            do checkUserInput(currentLevel.getText(), key);

            // Since the user have choose it's answer, advance to next round,
            // if available. Otherwise, we're done.
            let moreLevels = advanceLevel();

            if (~moreLevels) {
                let exit = true;
            }

            // Waits for a key to be released.
            while (~(key = 0)) {
                let key = Keyboard.keyPressed();
                do startGraphics();
            }
        }

        // Finished game. Show the user's score.
        do Text.printScore(score, currentLevelIdx + 1);

        return;
    }
}
